// Generated by CoffeeScript 1.12.3
(function() {
  var deepEqual, inherit, renderSchema;

  deepEqual = require('assert').deepEqual;

  inherit = require('./inherit');

  module.exports = renderSchema = function(root, dataStructures) {
    var el, exclusive, i, item, items, j, k, key, len, len1, len2, len3, m, member, n, name, option, optionSchema, prop, properties, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, required, schema, typeAttr;
    schema = {};
    switch (root.element) {
      case 'boolean':
      case 'string':
      case 'number':
        schema.type = root.element;
        if (root.content != null) {
          schema.example = root.content;
        }
        break;
      case 'enum':
        schema.type = 'enum';
        if ((((ref1 = root.content[0]) != null ? ref1.element : void 0) != null) && (((ref2 = root.content[0]) != null ? ref2.meta : void 0) == null)) {
          schema.itemType = root.content[0].element;
        }
        schema.properties = [];
        ref3 = root.content || [];
        for (j = 0, len = ref3.length; j < len; j++) {
          item = ref3[j];
          if (item.content != null) {
            el = {};
            if (item.element != null) {
              el.type = item.element;
            } else if (schema.itemType != null) {
              el.type = schema.itemType;
            }
            if (((ref4 = item.meta) != null ? ref4.description : void 0) != null) {
              el.description = item.meta.description;
            }
            el.name = item.content;
            schema.properties.push(el);
          }
        }
        if (((ref5 = root.attributes) != null ? (ref6 = ref5.samples) != null ? ref6[0][0].content : void 0 : void 0) != null) {
          schema.example = root.attributes.samples[0][0].content;
        }
        break;
      case 'array':
        schema.type = 'array';
        if (((ref7 = root.content) != null ? ref7[0].element : void 0) != null) {
          schema.itemType = root.content[0].element;
        }
        items = [];
        ref8 = root.content || [];
        for (k = 0, len1 = ref8.length; k < len1; k++) {
          item = ref8[k];
          items.push(renderSchema(item, dataStructures));
        }
        if (items.length === 1) {
          schema.items = items[0];
          if ((items[0].name != null)) {
            schema.items.itemType = items[0].name;
          }
        } else if (items.length > 1) {
          try {
            schema.items = items.reduce(function(l, r) {
              return deepEqual(l, r) || r;
            });
          } catch (error) {
            schema.items = {
              'properties': items
            };
          }
          schema.items.itemType = root.element;
        }
        break;
      case 'object':
      case 'option':
        schema.type = 'object';
        if (((ref9 = root.meta) != null ? ref9.id : void 0) != null) {
          schema.itemType = root.meta.id;
        }
        schema.properties = {};
        required = [];
        properties = root.content.slice(0);
        i = 0;
        while (i < properties.length) {
          member = properties[i];
          i++;
          if (member.element === 'ref') {
            ref = dataStructures[member.content.href];
            i--;
            properties.splice.apply(properties, [i, 1].concat(ref.content));
            continue;
          } else if (member.element === 'select') {
            exclusive = [];
            ref10 = member.content;
            for (m = 0, len2 = ref10.length; m < len2; m++) {
              option = ref10[m];
              optionSchema = renderSchema(option, dataStructures);
              ref11 = optionSchema.properties;
              for (key in ref11) {
                prop = ref11[key];
                exclusive.push(key);
                schema.properties[key] = prop;
              }
            }
            if (!schema.allOf) {
              schema.allOf = [];
            }
            schema.allOf.push({
              not: {
                required: exclusive
              }
            });
            continue;
          }
          key = member.content.key.content;
          schema.properties[key] = renderSchema(member.content.value, dataStructures);
          schema.properties[key].name = key;
          schema.properties[key].required = false;
          if (((ref12 = member.meta) != null ? ref12.description : void 0) != null) {
            schema.properties[key].description = member.meta.description;
          }
          if ((ref13 = member.attributes) != null ? ref13.typeAttributes : void 0) {
            typeAttr = member.attributes.typeAttributes;
            if (typeAttr.indexOf('required') !== -1) {
              if (required.indexOf(key) === -1) {
                required.push(key);
              }
            }
            if (typeAttr.indexOf('nullable') !== -1) {
              schema.properties[key].nullable = true;
            }
          }
        }
        for (n = 0, len3 = required.length; n < len3; n++) {
          name = required[n];
          schema.properties[name].required = true;
        }
        break;
      default:
        ref = dataStructures[root.element];
        if (ref) {
          schema = renderSchema(inherit(ref, root), dataStructures);
        }
    }
    if (((ref14 = root.attributes) != null ? ref14["default"] : void 0) != null) {
      schema["default"] = root.attributes["default"];
    }
    if (((ref15 = root.meta) != null ? ref15.id : void 0) != null) {
      schema.name = root.meta.id;
    }
    if (((ref16 = root.meta) != null ? ref16.description : void 0) != null) {
      schema.description = root.meta.description;
    }
    if ((ref17 = root.attributes) != null ? ref17.typeAttributes : void 0) {
      typeAttr = root.attributes.typeAttributes;
      if (typeAttr.indexOf('nullable') !== -1) {
        schema.nullable = true;
      }
    }
    return schema;
  };

}).call(this);
